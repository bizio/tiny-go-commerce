// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: shipping/v1/shipping.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Fulfillment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Fulfillment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Fulfillment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FulfillmentMultiError, or
// nil if none found.
func (m *Fulfillment) ValidateAll() error {
	return m.validate(true)
}

func (m *Fulfillment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := FulfillmentValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOrderId() <= 0 {
		err := FulfillmentValidationError{
			field:  "OrderId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := FulfillmentType_name[int32(m.GetType())]; !ok {
		err := FulfillmentValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := FulfillmentStatus_name[int32(m.GetStatus())]; !ok {
		err := FulfillmentValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetShipmentDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FulfillmentValidationError{
					field:  "ShipmentDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FulfillmentValidationError{
					field:  "ShipmentDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShipmentDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FulfillmentValidationError{
				field:  "ShipmentDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPickupDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FulfillmentValidationError{
					field:  "PickupDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FulfillmentValidationError{
					field:  "PickupDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPickupDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FulfillmentValidationError{
				field:  "PickupDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return FulfillmentMultiError(errors)
	}

	return nil
}

// FulfillmentMultiError is an error wrapping multiple validation errors
// returned by Fulfillment.ValidateAll() if the designated constraints aren't met.
type FulfillmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FulfillmentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FulfillmentMultiError) AllErrors() []error { return m }

// FulfillmentValidationError is the validation error returned by
// Fulfillment.Validate if the designated constraints aren't met.
type FulfillmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FulfillmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FulfillmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FulfillmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FulfillmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FulfillmentValidationError) ErrorName() string { return "FulfillmentValidationError" }

// Error satisfies the builtin error interface
func (e FulfillmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFulfillment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FulfillmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FulfillmentValidationError{}

// Validate checks the field values on ShipmentDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ShipmentDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShipmentDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShipmentDetailsMultiError, or nil if none found.
func (m *ShipmentDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ShipmentDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingNumber

	// no validation rules for Carrier

	// no validation rules for EstimatedDelivery

	if m.GetDestination() == nil {
		err := ShipmentDetailsValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShipmentDetailsValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShipmentDetailsValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShipmentDetailsValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ShipmentDetailsMultiError(errors)
	}

	return nil
}

// ShipmentDetailsMultiError is an error wrapping multiple validation errors
// returned by ShipmentDetails.ValidateAll() if the designated constraints
// aren't met.
type ShipmentDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShipmentDetailsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShipmentDetailsMultiError) AllErrors() []error { return m }

// ShipmentDetailsValidationError is the validation error returned by
// ShipmentDetails.Validate if the designated constraints aren't met.
type ShipmentDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShipmentDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShipmentDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShipmentDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShipmentDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShipmentDetailsValidationError) ErrorName() string { return "ShipmentDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ShipmentDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShipmentDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShipmentDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShipmentDetailsValidationError{}

// Validate checks the field values on PickupDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PickupDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PickupDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PickupDetailsMultiError, or
// nil if none found.
func (m *PickupDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *PickupDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStoreId()) < 1 {
		err := PickupDetailsValidationError{
			field:  "StoreId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PickupInstructions

	// no validation rules for PickupTime

	if len(errors) > 0 {
		return PickupDetailsMultiError(errors)
	}

	return nil
}

// PickupDetailsMultiError is an error wrapping multiple validation errors
// returned by PickupDetails.ValidateAll() if the designated constraints
// aren't met.
type PickupDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PickupDetailsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PickupDetailsMultiError) AllErrors() []error { return m }

// PickupDetailsValidationError is the validation error returned by
// PickupDetails.Validate if the designated constraints aren't met.
type PickupDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PickupDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PickupDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PickupDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PickupDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PickupDetailsValidationError) ErrorName() string { return "PickupDetailsValidationError" }

// Error satisfies the builtin error interface
func (e PickupDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPickupDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PickupDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PickupDetailsValidationError{}

// Validate checks the field values on ShippingAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ShippingAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShippingAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShippingAddressMultiError, or nil if none found.
func (m *ShippingAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *ShippingAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStreet()) < 1 {
		err := ShippingAddressValidationError{
			field:  "Street",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCity()) < 1 {
		err := ShippingAddressValidationError{
			field:  "City",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetState()) < 1 {
		err := ShippingAddressValidationError{
			field:  "State",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetZip()) < 1 {
		err := ShippingAddressValidationError{
			field:  "Zip",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCountry()) != 2 {
		err := ShippingAddressValidationError{
			field:  "Country",
			reason: "value length must be 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ShippingAddressMultiError(errors)
	}

	return nil
}

// ShippingAddressMultiError is an error wrapping multiple validation errors
// returned by ShippingAddress.ValidateAll() if the designated constraints
// aren't met.
type ShippingAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShippingAddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShippingAddressMultiError) AllErrors() []error { return m }

// ShippingAddressValidationError is the validation error returned by
// ShippingAddress.Validate if the designated constraints aren't met.
type ShippingAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShippingAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShippingAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShippingAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShippingAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShippingAddressValidationError) ErrorName() string { return "ShippingAddressValidationError" }

// Error satisfies the builtin error interface
func (e ShippingAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShippingAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShippingAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShippingAddressValidationError{}

// Validate checks the field values on CreateFulfillmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFulfillmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFulfillmentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFulfillmentRequestMultiError, or nil if none found.
func (m *CreateFulfillmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFulfillmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOrderId() <= 0 {
		err := CreateFulfillmentRequestValidationError{
			field:  "OrderId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateFulfillmentRequest_Type_NotInLookup[m.GetType()]; ok {
		err := CreateFulfillmentRequestValidationError{
			field:  "Type",
			reason: "value must not be in list [FULFILLMENT_TYPE_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := FulfillmentType_name[int32(m.GetType())]; !ok {
		err := CreateFulfillmentRequestValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetShipmentDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFulfillmentRequestValidationError{
					field:  "ShipmentDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFulfillmentRequestValidationError{
					field:  "ShipmentDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShipmentDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFulfillmentRequestValidationError{
				field:  "ShipmentDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPickupDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFulfillmentRequestValidationError{
					field:  "PickupDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFulfillmentRequestValidationError{
					field:  "PickupDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPickupDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFulfillmentRequestValidationError{
				field:  "PickupDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateFulfillmentRequestMultiError(errors)
	}

	return nil
}

// CreateFulfillmentRequestMultiError is an error wrapping multiple validation
// errors returned by CreateFulfillmentRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateFulfillmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFulfillmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFulfillmentRequestMultiError) AllErrors() []error { return m }

// CreateFulfillmentRequestValidationError is the validation error returned by
// CreateFulfillmentRequest.Validate if the designated constraints aren't met.
type CreateFulfillmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFulfillmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFulfillmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFulfillmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFulfillmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFulfillmentRequestValidationError) ErrorName() string {
	return "CreateFulfillmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFulfillmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFulfillmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFulfillmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFulfillmentRequestValidationError{}

var _CreateFulfillmentRequest_Type_NotInLookup = map[FulfillmentType]struct{}{
	0: {},
}

// Validate checks the field values on CreateFulfillmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFulfillmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFulfillmentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFulfillmentResponseMultiError, or nil if none found.
func (m *CreateFulfillmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFulfillmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFulfillment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFulfillmentResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFulfillmentResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFulfillment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFulfillmentResponseValidationError{
				field:  "Fulfillment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateFulfillmentResponseMultiError(errors)
	}

	return nil
}

// CreateFulfillmentResponseMultiError is an error wrapping multiple validation
// errors returned by CreateFulfillmentResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateFulfillmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFulfillmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFulfillmentResponseMultiError) AllErrors() []error { return m }

// CreateFulfillmentResponseValidationError is the validation error returned by
// CreateFulfillmentResponse.Validate if the designated constraints aren't met.
type CreateFulfillmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFulfillmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFulfillmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFulfillmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFulfillmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFulfillmentResponseValidationError) ErrorName() string {
	return "CreateFulfillmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFulfillmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFulfillmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFulfillmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFulfillmentResponseValidationError{}

// Validate checks the field values on GetFulfillmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFulfillmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFulfillmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFulfillmentRequestMultiError, or nil if none found.
func (m *GetFulfillmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFulfillmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetFulfillmentRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFulfillmentRequestMultiError(errors)
	}

	return nil
}

// GetFulfillmentRequestMultiError is an error wrapping multiple validation
// errors returned by GetFulfillmentRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFulfillmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFulfillmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFulfillmentRequestMultiError) AllErrors() []error { return m }

// GetFulfillmentRequestValidationError is the validation error returned by
// GetFulfillmentRequest.Validate if the designated constraints aren't met.
type GetFulfillmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFulfillmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFulfillmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFulfillmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFulfillmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFulfillmentRequestValidationError) ErrorName() string {
	return "GetFulfillmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFulfillmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFulfillmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFulfillmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFulfillmentRequestValidationError{}

// Validate checks the field values on GetFulfillmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFulfillmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFulfillmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFulfillmentResponseMultiError, or nil if none found.
func (m *GetFulfillmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFulfillmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFulfillment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFulfillmentResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFulfillmentResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFulfillment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFulfillmentResponseValidationError{
				field:  "Fulfillment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFulfillmentResponseMultiError(errors)
	}

	return nil
}

// GetFulfillmentResponseMultiError is an error wrapping multiple validation
// errors returned by GetFulfillmentResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFulfillmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFulfillmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFulfillmentResponseMultiError) AllErrors() []error { return m }

// GetFulfillmentResponseValidationError is the validation error returned by
// GetFulfillmentResponse.Validate if the designated constraints aren't met.
type GetFulfillmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFulfillmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFulfillmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFulfillmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFulfillmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFulfillmentResponseValidationError) ErrorName() string {
	return "GetFulfillmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFulfillmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFulfillmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFulfillmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFulfillmentResponseValidationError{}

// Validate checks the field values on UpdateFulfillmentStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateFulfillmentStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFulfillmentStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateFulfillmentStatusRequestMultiError, or nil if none found.
func (m *UpdateFulfillmentStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFulfillmentStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateFulfillmentStatusRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateFulfillmentStatusRequest_Status_NotInLookup[m.GetStatus()]; ok {
		err := UpdateFulfillmentStatusRequestValidationError{
			field:  "Status",
			reason: "value must not be in list [FULFILLMENT_STATUS_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := FulfillmentStatus_name[int32(m.GetStatus())]; !ok {
		err := UpdateFulfillmentStatusRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TrackingNumber

	if len(errors) > 0 {
		return UpdateFulfillmentStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateFulfillmentStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateFulfillmentStatusRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateFulfillmentStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFulfillmentStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFulfillmentStatusRequestMultiError) AllErrors() []error { return m }

// UpdateFulfillmentStatusRequestValidationError is the validation error
// returned by UpdateFulfillmentStatusRequest.Validate if the designated
// constraints aren't met.
type UpdateFulfillmentStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFulfillmentStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFulfillmentStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFulfillmentStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFulfillmentStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFulfillmentStatusRequestValidationError) ErrorName() string {
	return "UpdateFulfillmentStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFulfillmentStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFulfillmentStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFulfillmentStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFulfillmentStatusRequestValidationError{}

var _UpdateFulfillmentStatusRequest_Status_NotInLookup = map[FulfillmentStatus]struct{}{
	0: {},
}

// Validate checks the field values on UpdateFulfillmentStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateFulfillmentStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFulfillmentStatusResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateFulfillmentStatusResponseMultiError, or nil if none found.
func (m *UpdateFulfillmentStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFulfillmentStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFulfillment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateFulfillmentStatusResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateFulfillmentStatusResponseValidationError{
					field:  "Fulfillment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFulfillment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateFulfillmentStatusResponseValidationError{
				field:  "Fulfillment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateFulfillmentStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateFulfillmentStatusResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateFulfillmentStatusResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateFulfillmentStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFulfillmentStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFulfillmentStatusResponseMultiError) AllErrors() []error { return m }

// UpdateFulfillmentStatusResponseValidationError is the validation error
// returned by UpdateFulfillmentStatusResponse.Validate if the designated
// constraints aren't met.
type UpdateFulfillmentStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFulfillmentStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFulfillmentStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFulfillmentStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFulfillmentStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFulfillmentStatusResponseValidationError) ErrorName() string {
	return "UpdateFulfillmentStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFulfillmentStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFulfillmentStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFulfillmentStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFulfillmentStatusResponseValidationError{}
